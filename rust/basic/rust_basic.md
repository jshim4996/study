# Rust 공식 입문서

## 2025-01-06 시작

## 1장

    - Rust 경우 파일 명을 스네이크 표기법으로 작성한다.
    - 파일 명은 .rs
    - rustc 컴파일 명령어
    - 러스트에서는 탭 대신 스페이스 4칸 사용
    - ! 가 붙어 있다면 매크로 호출 코드 이다. => 매크로는 항상 함수와 같은 규칙을 따르지 않는다.
    - println! 의 인수로 넘겨준 'Hello, world' 문자열 그대로 출력되었다.
    - rust 경우 컴파일 언어로 rust 가 설치 되어 있지 않더라도 컴파일 된 실행 파일이 있다면 프로그램을 실행 시킬수 있다.
    - cargo 명령어는 러스트 프로젝트를 관리하는 도구이다. => 빌드 시스템 및 패키지 매니저
    - cargo 로 프로젝트를 생성한다면 기본적으로 gitclone 파일과 Git 저장소가 초기화 됩니다. 단, git 저장소가 이미 있다면 초기화 되지 않습니다.
    - 패키지를 크레이트 라고 부른다.
    - cargo build 명령어는 프로젝트를 빌드 하는 명령어이다.
    - cargo run 명령어는 프로젝트를 빌드 하고 실행 하는 명령어이다.
    - cargo check 명령어는 프로젝트를 빌드 하지 않고 컴파일 할 수 있는지 확인하는 명령어이다.
    - cargo run 명령어는 프로젝트를 빌드 하고 실행 하는 명령어이다.
    - cargo build --release 명령어는 프로젝트를 빌드 하고 최적화 하는 명령어이다. => 컴파일 시 최적화를 하여  컴파일 속도가 느린대신 러스트 코드가 더빠르게 작동된다.
    - 기존 rust 프로젝트를 사용할때 해당 cargo build 를 실행하면 동일하게 빌드 된다.

## 2장 추리 게임 만들기

    - 표준 라이브러리 집합을 프렐루드라 한다.
    - 크레이트는 러스트 코드 파일들의 모음 을 뜻한다.
    - 실행 가능한 바이너리 크레이트와 자체적 실행이 아닌 다른프로그램에서 사용하기 위한 용도인 라이브러리 크레이트가 있다.
    - cargo 는 실제 소스의 변경 또는 dependencies 의 변경이 있을 경우 컴파일을 진행합니다.
    - 카고 는 디팬던시 다운로드 할경우 의존성 있는 디펜던시도 함께 가져옵니다.
    - Cargo.lock 은 디펜던시에 있는 버전을 고정 시키는 파일이다. => 명시적으로 버전을 바꾸기 전까지 빌드 한 버전을 저장
    - cargo doc --open 통해 크레이트들이 저장된 파일을 저장 저장 하고 열어 볼수 있다.

## 3장 일반적인 프로그래밍 개념

    - 다른 언어와 동일하게 이 언어만 사용 가능한 키워드라는 집합이 있다. 이 집합은 함수명이나 변수명으로 사용 불가능 하다.
    - 러스트 에서 변수는 기본적으로 불변인다.
    - 변수 명 앞에 mut 키워드를 붙이면 변수를 변경 가능하게 할 수 있다.
    - 상수 값에는 mut 키워들르 사용할수 없다. 상수의 변수 선언 에는 const 키워드를 사용한다. 반드시 타입을 설정해야 한다.
    - 상수는 런타임에서만 계산될수 있는 결과 값이면 안된다.
    - 섀도잉: 같은 이름의 변수를 선언 할 수 있다.
    - 섀도잉 변수의 값은 스코프 안에서만 사용 가능 하다.
    - 동일한 변수명에 다른 타입에 값을 저장 하고 싶을때 섀동잉을 사용 한다.
    - 러스트는 정적 타입 언어 이다. => 즉 컴파일시 타입을 알수 있어야 한다.

    ### 3.2.1 스칼라 타입
    - 스칼라 타입은 정수, 부동소수점, 불리언, 문자 등 기본적인 데이터 타입을 말한다.
    - 정수형은 소수점이 없는 숫자입니다.
    | 길이    | 부호 있는 정수 | 부호 없는 정수 |
    |---------|----------------|----------------|
    | 8비트   | i8             | u8             |
    | 16비트  | i16            | u16            |
    | 32비트  | i32            | u32            |
    | 64비트  | i64            | u64            |
    | 128비트 | i128           | u128           |
    | arch    | isize          | usize          |

    - 부호 있는 정수는 음수 까지 (i)
    - 부호 없는 정수는 음수가 없다. (u)
    -arch 는 컴퓨터 아키텍처에 따라 다른 크기를 가진다.
    | 숫자 리터럴 | 예시        |
    |-------------|------------|
    | 10진수      | 98_222     |
    | 16진수      | 0xff       |
    | 8진수       | 0o77       |
    | 2진수       | 0b1111_0000|
    | 바이트(u8)  | b'A'       |

    - 정수 의 크기가 확실하지 않을경우 러스트의 기본 값이 i32를 사용 하는것이 좋다.
    - --release 플래그를 사용하여 코드를 릴리스 모드로 컴파일 하는경우 패닉을 방생시키는 정수 오버플로우 검사를 실행 파일에 포함시키지 않습니다. 러스트의 경우 정수 오버플로우로 발생하는 패닉이 발생할경우 최대값을 데이터 타입의 최소값으로 변경 시킵니다.

    - 부동소수점 타입은 소수점을 가진 숫자형을 저장할때 사용하는 타입입니다.
    - 부동 소수점 타입은 f32 와 f64 가 있습니다.
    - 기본적으로 부동 소수점 타입은 f64 를 사용 하는것이 좋다.

    - 러스트는 모든 숫자 타입에 대해서 기본 수학 연산 기능을 제공한다.
    - 러스트에서 제공하는 연산자 목록
        - 덧셈: +
        - 뺄셈: -
        - 곱셈: *
        - 나눗셈: /
        - 나머지: %
        - 비트 AND: &
        - 비트 OR: |
        - 비트 XOR: ^
        - 비트 NOT: !
        - 왼쪽 시프트: <<
        - 오른쪽 시프트: >>
        - 대입: =
        - 복합 대입: +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=
        - 비교: ==, !=, <, >, <=, >=
        - 논리: &&, ||, !

    - boolean 타입은 true 와 false 두가지 값만 가질수 있습니다.
    - 러스트에서 불리언 타입은 bool 이라는 이름으로 제공 됩니다.
    - 불리언 값은 1바이트 입니다.

    - 문자 타입 문자형 데이터를 저장하는 타입입니다.
    - char 타입은 작은 따옴표를 쓴다.
    - 문자열 리터럴 경우 큰타옴표로 작성한다.
    - char 타입은 4바이트 크기를 가진다.

    ### 3.2.2 복합 타입
    - 복합 타입은 여러 값을 하나의 타입으로 묶을수 있습니다.
    - 러스트에서 제공하는 복합 타입은 튜플과 배열 두가지 입니다.
    - 튜플은 다양한 타입의 여러값을 묶어 하나의 복합 타입으로 만들수 있습니다.
    - 튜플은 고정된 길이를 갖습니다.
    - 튜플은 한번 선언되면 그 크기를 늘리거나 줄일수 없습니다.
    - 튜플내 타입들은 서로 달라도 됩니다.
    - 튜플은 타입을 명시 하지 않아도 됩니다.
    - 튜플 내부 데이터에 접근 하는 방법으로는 인덱스를 사용 하는 방법과 패턴 매칭을 사용 하는 방법이 있습니다. (패턴은 구조 해체를 사용)
    - 인덱스 접근 방식은 '변수명.인텍스' 형태로 사용 합니다.
    - 아무값도 없는 튜플은 유닛이락는 특별한 이름을 가진다.
    - 표현식에 아무값도 반환하지 않으면 암묵적으로 유닛값을 반환 합니다.

    - 배열 타입은 여러값의 집합을 저장하는 타입입니다.
    - 배열은 모든 요소가 같은 타입이어야 합니다.
    - 러스트의 배열은 고정된 길이를 가집니다.
    - 벡터는 표준 라이브러리가 제공하는 배열과 유사한 컬렉션 타입이다.
    - 벡터 타입은 요소의 크기를 늘리거나 줄일수 있다.
    - 요소의 갯수가 바뀔 필요가 없을경우 배열 타입이 더 유용하다.
    - 배열은 스택에 할당될 수 있는 고정된 크기의 단일 메모리 뭉치이다.
    - 배열은 넘는 인덱스 접근 시 패닉을 발생 시킨다.

    ### 3.3 함수
    - 러스트 코드는 함수나 병수 이름을 스네이크 표기법으로 작성한다.
    - 함수는 fn 키워드를 사용하여 선언 한다.
    - 려스트는 함수 위치를 고려 하지 않으며, 호출하는 쪽에서 볼 수 있는 스코프 어딘가에 정의만 되어 있으면 됩니다.
    - 매개변수 에는 반드시 타입을 지정해야 한다. => 다른 코드에서 함수를 사용할때 타입을 컴파일러가 추측하지 않게 하기 위해 이렇게 설계

    ### 3.3.2 구문과 표현식
    - 구문은 어떤 동작을 수행하고 값을 반환하지 않는 명령입니다.
    - 표현식은 결과값을 평가합니다.
    - 중괄호로 만들어진 새로운 스코프 블록도 표현식 이다.
    - 현식의 마지막에는 세미 콜론을 붙이지 않는다. 붙이면 구문이 된다.

    ### 3.3.3 함수 반환값
    - 함수의 반환값 타입은 '() ->'' 타입 으로 표현 합니다.
    - return 로 지정된 값이 반환된다.
    - 러스트 에서 함수는 암묵적으로 마지막 표현식 값을 반환한다.
    - 반환값을 지정 하고 값을 반환 하지 않으면 유닛타입으로 표현 되며 오류가 발생합니다.

    ### 3.4 주석
    - // 주석

    ### 3.5 제어 흐름
    - 흐름제어 일반적 재료는 if 표현식과 반복문 이다.

    ### 3.5.1 if 표현식
    - 표현식 코드에는 반드시 bool 타입이 있어야 한다. => 아니면 오류 발생
    - 러스트는 불리언이 아닌값을 불리언 타입으로 자동 변환 하지 않는다.
    - bool 타입이 아니라면 반드시 bool 타입으로 변환 해야 한다.
    - if 는 표현식이기 때문에 let 구문에 우변에 사용할수 있다.
    -  if else 의 반환값의 타입이 다르다면 rust 는 컴파일중에 오류를 발생시킨다. 컴파일 시점에 변수의 타입이 무엇인지 확실히 알아야한다. 런타임에 변수 타입이 정의되도록 할수 없다.(if else 구문의 타입이 다르면 런타임 환경에서 변수의 타입을 알수 있게됨);

    ### 3.5.2 반복문
    - 한번이상의 반복 작업이 필요할경우 반복문을 사용한다.
    - 반복 키워드로 loop 를 사용한다.
    - loop 키워드의 경우 break 키워드를 사용하여 반복문을 종료 할수 있다.
    - loop 키워드의 반환 값을 원할경우 break 키워드 뒤에 결과값을 작성한다.
    - loop 또한 표현식이기이 변수에 할당할수 있다. => 결과값 평가됨
    - loop break 나 continue 같은 경우 키워드 바로 바깥쪽 loop 에 적용된다.
    - loop 라벨을 통해 loop 안에 loop 에서 상위 loop 를 break 나 continue 할 수 있다. (라벨 이름 뒤에 콜론을 붙인다.)
    - loop 라벨의 경우 라벨 이름 앞에 콜론을 붙인다.
    - while 조건이 false 일때 반복문을 종료 한다.
    - for 요소값을 순서대로 가져온다.



    ** 코드 블록은 블록안 마지막 표현식이 계산하고, 숫자는 그자체로 표현식임을 기억하자.
    ** Range 타입은 Rust에서 특정 범위의 값을 표현하는 데 사용되는 타입입니다. 주로 반복문이나 슬라이스를 다룰 때 유용하게 사용됩니다. Range는 두 개의 경계값을 가지고 있으며, 이 경계값 사이의 모든 값을 포함하거나 포함하지 않을 수 있습니다.
